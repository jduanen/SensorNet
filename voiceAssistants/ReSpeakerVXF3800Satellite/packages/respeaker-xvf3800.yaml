substitutions:
  voice_assist_idle_phase_id: '1'
  voice_assist_waiting_for_command_phase_id: '2'
  voice_assist_listening_for_command_phase_id: '3'
  voice_assist_thinking_phase_id: '4'
  voice_assist_replying_phase_id: '5'
  voice_assist_not_ready_phase_id: '10'
  voice_assist_error_phase_id: '11'
  hidden_ssid: 'false'
  mute_switch_on_sound_file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/mute_switch_on.flac
  mute_switch_off_sound_file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/mute_switch_off.flac
  timer_finished_sound_file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/timer_finished.flac
  wake_word_triggered_sound_file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/wake_word_triggered.flac
  center_button_press_sound_file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/center_button_press.flac
  center_button_double_press_sound_file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/center_button_double_press.flac
  center_button_triple_press_sound_file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/center_button_triple_press.flac
  center_button_long_press_sound_file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/center_button_long_press.flac
  factory_reset_initiated_sound_file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/factory_reset_initiated.mp3
  factory_reset_cancelled_sound_file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/factory_reset_cancelled.mp3
  factory_reset_confirmed_sound_file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/factory_reset_confirmed.mp3
  error_cloud_expired_sound_file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/error_cloud_expired.mp3
esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}
  project:
    name: formatbce.Respeaker XVF3800 Satellite
    version: 2026.1.2
  min_version: 2026.1.0
  on_boot:
    - priority: 375
      then:
        - sensor.template.publish:
            id: next_timer
            state: -1
        - script.execute: control_leds
        - delay: 10min
        - if:
            condition:
              lambda: return id(init_in_progress);
            then:
              - lambda: id(init_in_progress) = false;
              - script.execute: control_leds
    - priority: -100
      then:
        - lambda: id(alarm_time).publish_state(id(saved_alarm_time));
        - lambda: 'auto call = id(alarm_action).make_call();

            call.set_option(id(saved_alarm_action));

            call.perform();'
        - lambda: 'setenv("TZ", id(saved_time_zone).c_str(), 1);

            tzset();'
  comment: ${comment}
esp32:
  board: esp32-s3-devkitc-1
  cpu_frequency: 240MHz
  variant: esp32s3
  flash_size: 8MB
  framework:
    type: esp-idf
    version: recommended
    sdkconfig_options:
      CONFIG_ESP32S3_DATA_CACHE_64KB: y
      CONFIG_ESP32S3_DATA_CACHE_LINE_64B: y
      CONFIG_ESP32S3_INSTRUCTION_CACHE_32KB: y
      CONFIG_SPIRAM_RODATA: y
      CONFIG_SPIRAM_FETCH_INSTRUCTIONS: y
      CONFIG_BT_ALLOCATION_FROM_SPIRAM_FIRST: y
      CONFIG_BT_BLE_DYNAMIC_ENV_MEMORY: y
      CONFIG_MBEDTLS_EXTERNAL_MEM_ALLOC: y
      CONFIG_MBEDTLS_SSL_PROTO_TLS1_3: y
wifi:
  id: wifi_id
  fast_connect: ${hidden_ssid}
  ssid: wifi_ssid
  password: wifi_password
  power_save_mode: none
  reboot_timeout: 10min
  on_connect:
    - lambda: id(improv_ble_in_progress) = false;
    - script.execute: control_leds
  on_disconnect:
    - script.execute: control_leds
network:
  enable_ipv6: true
logger:
  level: ${log_level}
  initial_level: INFO
  logs:
    sensor: WARN
    voice_assistant: INFO
    micro_wake_word: INFO
    i2s_audio: WARN
    respeaker_xvf3800: INFO
api:
  id: api_id
  actions:
    - action: set_led_color
      variables:
        red: float
        green: float
        blue: float
      then:
        - lambda: 'id(user_led_ring_color_r) = std::min(255.0f, std::max(0.0f, red));

            id(user_led_ring_color_g) = std::min(255.0f, std::max(0.0f, green));

            id(user_led_ring_color_b) = std::min(255.0f, std::max(0.0f, blue));'
        - select.set:
            id: user_led_color_preset
            option: Custom
    - action: start_va
      then:
        - voice_assistant.start
    - action: stop_va
      then:
        - voice_assistant.stop
    - action: set_alarm_time
      variables:
        alarm_time_hh_mm: string
      then:
        - lambda: "if (alarm_time_hh_mm.length() == 5 &&\n  isdigit(alarm_time_hh_mm[0])\
            \ && isdigit(alarm_time_hh_mm[1]) &&\n  isdigit(alarm_time_hh_mm[3]) &&\
            \ isdigit(alarm_time_hh_mm[4])) {\n    id(alarm_time).publish_state(alarm_time_hh_mm);\n\
            \    id(saved_alarm_time) = alarm_time_hh_mm;\n  }"
    - action: set_time_zone
      variables:
        posix_time_zone: string
      then:
        - lambda: 'setenv("TZ", posix_time_zone.c_str(), 1);

            tzset();

            id(saved_time_zone) = posix_time_zone;

            id(publish_current_time).execute();'
  on_client_connected:
    - script.execute: control_leds
  on_client_disconnected:
    - script.execute: control_leds
http_request: null
ota:
  - platform: esphome
    id: ota_esphome
    password: ota_password
i2c:
  - id: internal_i2c
    sda: GPIO5
    scl: GPIO6
    scan: true
    frequency: 100kHz
psram:
  mode: octal
  speed: 80MHz
  ignore_not_found: false
globals:
  - id: user_led_ring_color_r
    type: float
    restore_value: 'yes'
    initial_value: '255.0'
  - id: user_led_ring_color_g
    type: float
    restore_value: 'yes'
    initial_value: '0.0'
  - id: user_led_ring_color_b
    type: float
    restore_value: 'yes'
    initial_value: '255.0'
  - id: effect_color_r
    type: float
    restore_value: 'no'
    initial_value: '255.0'
  - id: effect_color_g
    type: float
    restore_value: 'no'
    initial_value: '0.0'
  - id: effect_color_b
    type: float
    restore_value: 'no'
    initial_value: '255.0'
  - id: effect_brightness
    type: float
    restore_value: 'no'
    initial_value: '1.0'
  - id: effect_speed
    type: float
    restore_value: 'yes'
    initial_value: '0.05'
  - id: init_in_progress
    type: bool
    restore_value: 'no'
    initial_value: 'true'
  - id: improv_ble_in_progress
    type: bool
    restore_value: 'no'
    initial_value: 'false'
  - id: voice_assistant_phase
    type: int
    restore_value: 'no'
    initial_value: ${voice_assist_not_ready_phase_id}
  - id: saved_alarm_time
    type: std::string
    restore_value: 'yes'
    initial_value: '"Unknown"'
  - id: saved_time_zone
    type: std::string
    restore_value: 'yes'
    initial_value: '"UTC0"'
  - id: saved_alarm_action
    type: std::string
    restore_value: 'yes'
    initial_value: '"Play sound"'
  - id: first_active_timer
    type: voice_assistant::Timer
    restore_value: 'no'
  - id: is_timer_active
    type: bool
    restore_value: 'no'
  - id: factory_reset_requested
    type: bool
    restore_value: 'no'
    initial_value: 'false'
  - id: current_led_effect
    type: std::string
    restore_value: 'no'
    initial_value: '"off"'
  - id: volume_display_active
    type: bool
    restore_value: 'no'
    initial_value: 'false'
  - id: last_led_update_time
    type: uint32_t
    restore_value: 'no'
    initial_value: '0'
  - id: animated_beam_position
    type: float
    restore_value: 'no'
    initial_value: '0.0'
time:
  - platform: homeassistant
    id: homeassistant_time
    on_time:
      - seconds: 0
        minutes: /1
        then:
          - script.execute: check_alarm
    on_time_sync:
      - script.execute: publish_current_time
switch:
  - platform: template
    id: mute_sound
    name: Mute-unmute sound
    icon: mdi:bullhorn
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
  - platform: template
    id: wake_sound
    name: Wake sound
    icon: mdi:bullhorn
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
  - platform: template
    id: timer_ringing
    optimistic: true
    internal: true
    restore_mode: ALWAYS_OFF
    on_turn_off:
      - micro_wake_word.disable_model: stop
      - script.execute: disable_repeat
      - if:
          condition:
            media_player.is_announcing:
              id: external_media_player
          then:
            media_player.stop:
              announcement: true
              id: external_media_player
      - mixer_speaker.apply_ducking:
          id: media_mixing_input
          decibel_reduction: 0
          duration: 1.0s
      - script.execute: control_leds
    on_turn_on:
      - mixer_speaker.apply_ducking:
          id: media_mixing_input
          decibel_reduction: 20
          duration: 0.0s
      - micro_wake_word.enable_model: stop
      - script.execute: ring_timer
      - script.execute: control_leds
      - delay: 15min
      - switch.turn_off: timer_ringing
  - platform: template
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    id: alarm_on
    icon: mdi:bell-badge
    name: Alarm on
    on_turn_on:
      - script.execute: control_leds
    on_turn_off:
      - script.execute: control_leds
binary_sensor: null
number:
  - platform: template
    id: user_led_ring_brightness
    name: LED Ring Brightness
    icon: mdi:brightness-6
    entity_category: config
    optimistic: true
    restore_value: true
    min_value: 0.4
    max_value: 1.0
    step: 0.05
    initial_value: 0.8
    mode: slider
sensor:
  - platform: template
    id: next_timer
    name: Next timer
    update_interval: never
    disabled_by_default: true
    device_class: duration
    unit_of_measurement: s
    icon: mdi:timer
    accuracy_decimals: 0
  - platform: wifi_signal
    id: wifi_rssi
    name: ${friendly_name} WiFi Signal
text_sensor:
  - platform: template
    id: next_timer_name
    name: Next timer name
    icon: mdi:timer
    disabled_by_default: true
  - platform: template
    name: Alarm time
    id: alarm_time
    icon: mdi:bell-ring
  - platform: template
    name: Current device time
    id: current_time
    icon: mdi:clock
interval:
  - interval: 50ms
    id: led_animation_interval
    then:
      - lambda: "if (id(volume_display_active)) {\n  id(update_volume_display_effect).execute();\n\
          \  return;\n}\nstd::string effect = id(current_led_effect);\nif (effect\
          \ == \"off\") {\n  return;\n} else if (effect == \"breathe\") {\n  id(update_breathe_effect).execute();\n\
          } else if (effect == \"rainbow\") {\n  id(update_rainbow_effect).execute();\n\
          } else if (effect == \"comet_cw\") {\n  id(update_comet_cw_effect).execute();\n\
          } else if (effect == \"comet_ccw\") {\n  id(update_comet_ccw_effect).execute();\n\
          } else if (effect == \"twinkle\") {\n  id(update_twinkle_effect).execute();\n\
          } else if (effect == \"timer_tick\") {\n  id(update_timer_tick_effect).execute();\n\
          } else if (effect == \"led_beam\") {\n  id(update_led_beam_effect).execute();\n\
          }"
script:
  - id: led_set_effect
    mode: restart
    parameters:
      effect: std::string
      r: float
      g: float
      b: float
      speed: float
      brightness: float
    then:
      - lambda: "// Update global variables with the new parameters\nid(effect_color_r)\
          \ = r;\nid(effect_color_g) = g;\nid(effect_color_b) = b;\nid(effect_speed)\
          \ = speed;\nid(effect_brightness) = brightness;\nid(current_led_effect)\
          \ = effect;\n\n// Handle the two types of effects: Off and Animated\nif\
          \ (effect == \"off\") {\n  uint32_t colors[12] = {0};\n  id(respeaker).set_led_ring(colors);\n\
          } else {\n  id(last_led_update_time) = millis(); // Reset timer for smooth\
          \ animation start\n}"
  - id: update_breathe_effect
    then:
      - lambda: 'static float phase = 0.0f;

          uint32_t now = millis();

          float dt = (now - id(last_led_update_time)) / 1000.0f;

          id(last_led_update_time) = now;


          phase += dt * id(effect_speed);

          while (phase >= 1.0f) phase -= 1.0f;


          float master_brightness = id(user_led_ring_brightness).state * id(effect_brightness);

          float breath_brightness = 0.5f * (1.0f + sinf(phase * 2.0f * M_PI)) * master_brightness;


          uint8_t r = (uint8_t)(id(effect_color_r) * breath_brightness);

          uint8_t g = (uint8_t)(id(effect_color_g) * breath_brightness);

          uint8_t b = (uint8_t)(id(effect_color_b) * breath_brightness);

          uint32_t current_color = (r << 16) | (g << 8) | b;


          uint32_t colors[12];

          for (int i = 0; i < 12; i++) colors[i] = current_color;

          id(respeaker).set_led_ring(colors);'
  - id: update_rainbow_effect
    then:
      - lambda: "static float hue_offset = 0.0f;\nuint32_t now = millis();\nfloat\
          \ dt = (now - id(last_led_update_time)) / 1000.0f;\nid(last_led_update_time)\
          \ = now;\n\nhue_offset += dt * id(effect_speed);\nif (hue_offset >= 1.0f)\
          \ hue_offset -= 1.0f;\n\nconstexpr int NUM_LEDS = 12;\nconstexpr float HUE_STEP\
          \ = 1.0f / NUM_LEDS;\nuint32_t colors[NUM_LEDS];\nfloat brightness = id(user_led_ring_brightness).state\
          \ * id(effect_brightness);\n\nfloat current_hue = hue_offset;\nfor (int\
          \ i = 0; i < NUM_LEDS; i++) {\n  float r, g, b;\n  if (current_hue >= 1.0f)\
          \ current_hue -= 1.0f;\n  hsv_to_rgb((int)(current_hue * 360.0f), 1.0f,\
          \ brightness, r, g, b);\n  colors[i] = ((uint8_t)(r * 255.0f) << 16) | ((uint8_t)(g\
          \ * 255.0f) << 8) | ((uint8_t)(b * 255.0f));\n  current_hue += HUE_STEP;\n\
          }\nid(respeaker).set_led_ring(colors);"
  - id: update_comet_cw_effect
    then:
      - lambda: "static float comet_pos = 0.0f;\nuint32_t now = millis();\nfloat dt\
          \ = (now - id(last_led_update_time)) / 1000.0f;\nid(last_led_update_time)\
          \ = now;\n\nconstexpr int NUM_LEDS = 12;\nconstexpr int BASE_TAIL = 3;\n\
          \nfloat leds_per_sec = id(effect_speed) * NUM_LEDS;\ncomet_pos += dt * leds_per_sec;\n\
          while (comet_pos >= NUM_LEDS) comet_pos -= NUM_LEDS;\n\nint head_index =\
          \ (int)comet_pos;\nint tail_length = BASE_TAIL + (int)(id(effect_speed));\n\
          if (tail_length > NUM_LEDS - 1) tail_length = NUM_LEDS - 1;\n\nuint32_t\
          \ colors[NUM_LEDS] = {0};\nfloat brightness = id(user_led_ring_brightness).state\
          \ * id(effect_brightness);\n\nuint8_t head_r = (uint8_t)(id(effect_color_r)\
          \ * brightness);\nuint8_t head_g = (uint8_t)(id(effect_color_g) * brightness);\n\
          uint8_t head_b = (uint8_t)(id(effect_color_b) * brightness);\n\ncolors[head_index\
          \ % NUM_LEDS] = (head_r << 16) | (head_g << 8) | head_b;\n\nfor (int i =\
          \ 1; i <= tail_length; i++) {\n  float tail_factor = (float)i / (tail_length\
          \ + 1);\n  float tail_brightness = (1.0f - tail_factor) * brightness;\n\
          \  uint8_t r = (uint8_t)(id(effect_color_r) * tail_brightness);\n  uint8_t\
          \ g = (uint8_t)(id(effect_color_g) * tail_brightness);\n  uint8_t b = (uint8_t)(id(effect_color_b)\
          \ * tail_brightness);\n  int tail_index = (head_index - i + NUM_LEDS) %\
          \ NUM_LEDS;\n  colors[tail_index] = (r << 16) | (g << 8) | b;\n}\nid(respeaker).set_led_ring(colors);"
  - id: update_comet_ccw_effect
    then:
      - lambda: "static float comet_pos = 0.0f;\nuint32_t now = millis();\nfloat dt\
          \ = (now - id(last_led_update_time)) / 1000.0f;\nid(last_led_update_time)\
          \ = now;\n\nconstexpr int NUM_LEDS = 12;\nconstexpr int BASE_TAIL = 3;\n\
          \nfloat leds_per_sec = id(effect_speed) * NUM_LEDS;\ncomet_pos -= dt * leds_per_sec;\n\
          while (comet_pos < 0.0f) comet_pos += NUM_LEDS;\n\nint head_index = (int)comet_pos;\n\
          int tail_length = BASE_TAIL + (int)(id(effect_speed));\nif (tail_length\
          \ > NUM_LEDS - 1) tail_length = NUM_LEDS - 1;\n\nuint32_t colors[NUM_LEDS]\
          \ = {0};\nfloat brightness = id(user_led_ring_brightness).state * id(effect_brightness);\n\
          \nuint8_t head_r = (uint8_t)(id(effect_color_r) * brightness);\nuint8_t\
          \ head_g = (uint8_t)(id(effect_color_g) * brightness);\nuint8_t head_b =\
          \ (uint8_t)(id(effect_color_b) * brightness);\n\ncolors[head_index % NUM_LEDS]\
          \ = (head_r << 16) | (head_g << 8) | head_b;\n\nfor (int i = 1; i <= tail_length;\
          \ i++) {\n  float tail_factor = (float)i / (tail_length + 1);\n  float tail_brightness\
          \ = (1.0f - tail_factor) * brightness;\n  uint8_t r = (uint8_t)(id(effect_color_r)\
          \ * tail_brightness);\n  uint8_t g = (uint8_t)(id(effect_color_g) * tail_brightness);\n\
          \  uint8_t b = (uint8_t)(id(effect_color_b) * tail_brightness);\n  int tail_index\
          \ = (head_index + i) % NUM_LEDS;\n  colors[tail_index] = (r << 16) | (g\
          \ << 8) | b;\n}\nid(respeaker).set_led_ring(colors);"
  - id: update_twinkle_effect
    then:
      - lambda: "constexpr int NUM_LEDS = 12;\nstatic float led_brightness[NUM_LEDS]\
          \ = {0.0f};\nstatic float led_fade_speed[NUM_LEDS] = {0.0f};\n\nuint32_t\
          \ now = millis();\nfloat dt = (now - id(last_led_update_time)) / 1000.0f;\n\
          id(last_led_update_time) = now;\n\n// Update existing twinkles\nfor (int\
          \ i = 0; i < NUM_LEDS; i++) {\n  if (led_fade_speed[i] != 0.0f) {\n    led_brightness[i]\
          \ += led_fade_speed[i] * dt;\n    if (led_fade_speed[i] > 0.0f && led_brightness[i]\
          \ >= 1.0f) {\n      led_brightness[i] = 1.0f;\n      led_fade_speed[i] *=\
          \ -1.0f;\n    } else if (led_fade_speed[i] < 0.0f && led_brightness[i] <=\
          \ 0.0f) {\n      led_brightness[i] = 0.0f;\n      led_fade_speed[i] = 0.0f;\n\
          \    }\n  }\n}\n\n// Start new twinkles\nfloat twinkle_chance = dt * id(effect_speed);\n\
          if (random_float() < twinkle_chance) {\n  int led_to_start = (int)(random_float()\
          \ * NUM_LEDS);\n  if (led_fade_speed[led_to_start] == 0.0f) {\n    led_brightness[led_to_start]\
          \ = 0.0f;\n    float min_speed = 1.5f, max_speed = 3.0f;\n    led_fade_speed[led_to_start]\
          \ = min_speed + (random_float() * (max_speed - min_speed));\n  }\n}\n\n\
          // Render colors\nuint32_t colors[NUM_LEDS];\nfloat master_brightness =\
          \ id(user_led_ring_brightness).state * id(effect_brightness);\n\nfor (int\
          \ i = 0; i < NUM_LEDS; i++) {\n  float current_led_brightness = led_brightness[i]\
          \ * master_brightness;\n  uint8_t r = (uint8_t)(id(effect_color_r) * current_led_brightness);\n\
          \  uint8_t g = (uint8_t)(id(effect_color_g) * current_led_brightness);\n\
          \  uint8_t b = (uint8_t)(id(effect_color_b) * current_led_brightness);\n\
          \  colors[i] = (r << 16) | (g << 8) | b;\n}\nid(respeaker).set_led_ring(colors);"
  - id: update_timer_tick_effect
    then:
      - lambda: "constexpr int NUM_LEDS = 12;\nstatic int tick_index = 0;\n\nuint32_t\
          \ now = millis();\n// Only update tick position every 100ms to reduce I2C\
          \ traffic\nstatic uint32_t last_tick_update = 0;\nif (now - last_tick_update\
          \ >= 100) {\n  tick_index = (tick_index - 1 + NUM_LEDS) % NUM_LEDS;\n  last_tick_update\
          \ = now;\n}\n\nuint32_t colors[NUM_LEDS] = {0};\nuint32_t seconds_left =\
          \ id(first_active_timer).seconds_left;\nuint32_t total_seconds = id(first_active_timer).total_seconds;\n\
          \nfloat timer_ratio = (float)NUM_LEDS * seconds_left / std::max(total_seconds,\
          \ (uint32_t)1);\n\nfloat master_brightness = id(user_led_ring_brightness).state\
          \ * id(effect_brightness);\n\nfor (int i = 0; i < NUM_LEDS; i++) {\n  float\
          \ bar_brightness = clamp(timer_ratio - i, 0.0f, 1.0f);\n  if (bar_brightness\
          \ > 0.0f) {\n    float tick_dip = (i == tick_index) ? 0.9f : 1.0f;\n   \
          \ float final_brightness = bar_brightness * tick_dip * master_brightness;\n\
          \    uint8_t r = (uint8_t)(id(effect_color_r) * final_brightness);\n   \
          \ uint8_t g = (uint8_t)(id(effect_color_g) * final_brightness);\n    uint8_t\
          \ b = (uint8_t)(id(effect_color_b) * final_brightness);\n    colors[i] =\
          \ (r << 16) | (g << 8) | b;\n  }\n}\nid(respeaker).set_led_ring(colors);"
  - id: update_volume_display_effect
    then:
      - lambda: "constexpr int NUM_LEDS = 12;\nuint32_t colors[NUM_LEDS] = {0};\n\n\
          if (id(external_media_player).is_ready()) {\n  bool is_muted = id(external_media_player).is_muted();\n\
          \  float volume = id(external_media_player).volume;\n\n  if (is_muted ||\
          \ volume == 0.0f) {\n    uint32_t mute_color = (255 << 16); // Red\n   \
          \ colors[0] = mute_color;\n    colors[6] = mute_color;\n  } else {\n   \
          \ float num_leds_on = volume * NUM_LEDS;\n    float master_brightness =\
          \ id(user_led_ring_brightness).state * id(effect_brightness);\n\n    for\
          \ (int i = 0; i < NUM_LEDS; i++) {\n      float brightness = clamp(num_leds_on\
          \ - i, 0.0f, 1.0f);\n      if (brightness > 0.0f) {\n        uint8_t r =\
          \ (uint8_t)(id(effect_color_r) * brightness * master_brightness);\n    \
          \    uint8_t g = (uint8_t)(id(effect_color_g) * brightness * master_brightness);\n\
          \        uint8_t b = (uint8_t)(id(effect_color_b) * brightness * master_brightness);\n\
          \        colors[i] = (r << 16) | (g << 8) | b;\n      }\n    }\n  }\n}\n\
          id(respeaker).set_led_ring(colors);"
  - id: update_led_beam_effect
    then:
      - lambda: "constexpr int NUM_LEDS = 12;\nconstexpr int FADE_LEDS = 3;\nconstexpr\
          \ float TRANSITION_DURATION = 0.5f; // Duration of the smooth transition\n\
          uint32_t colors[NUM_LEDS] = {0};\n\nuint32_t now = millis();\nfloat dt =\
          \ (now - id(last_led_update_time)) / 1000.0f;\nid(last_led_update_time)\
          \ = now;\n\nif (id(beam_direction).has_state()) {\n  // CORRECTING THE OFFSET:\
          \ add 5 from the sensor reading\n  float target_pos = ((int)id(beam_direction).state\
          \ + 5) % NUM_LEDS;\n  float current_pos = id(animated_beam_position);\n\n\
          \  // Calculate the shortest path around the circle\n  float diff = target_pos\
          \ - current_pos;\n  if (diff > NUM_LEDS / 2.0f) {\n    diff -= NUM_LEDS;\n\
          \  } else if (diff < -NUM_LEDS / 2.0f) {\n    diff += NUM_LEDS;\n  }\n\n\
          \  // Move current position towards target\n  if (abs(diff) > 0.01f) {\n\
          \    float move_speed = diff / TRANSITION_DURATION;\n    current_pos +=\
          \ move_speed * dt;\n  } else {\n    current_pos = target_pos;\n  }\n\n \
          \ // Handle wrap-around for the animated position\n  if (current_pos >=\
          \ NUM_LEDS) current_pos -= NUM_LEDS;\n  if (current_pos < 0.0f) current_pos\
          \ += NUM_LEDS;\n\n  id(animated_beam_position) = current_pos;\n\n  // Render\
          \ the smoothed beam\n  float master_brightness = id(user_led_ring_brightness).state\
          \ * id(effect_brightness);\n\n  for (int i = 0; i < NUM_LEDS; i++) {\n \
          \   // Calculate circular distance from current LED to the animated position\n\
          \    float dist = abs(i - current_pos);\n    if (dist > NUM_LEDS / 2.0f)\
          \ {\n      dist = NUM_LEDS - dist;\n    }\n\n    // Calculate brightness\
          \ based on distance (linear falloff)\n    float brightness_factor = 1.0f\
          \ - (dist / (FADE_LEDS + 1.0f));\n    brightness_factor = std::max(0.0f,\
          \ brightness_factor);\n\n    if (brightness_factor > 0.0f) {\n      float\
          \ final_brightness = brightness_factor * master_brightness;\n      uint8_t\
          \ r = (uint8_t)(id(effect_color_r) * final_brightness);\n      uint8_t g\
          \ = (uint8_t)(id(effect_color_g) * final_brightness);\n      uint8_t b =\
          \ (uint8_t)(id(effect_color_b) * final_brightness);\n      colors[i] = (r\
          \ << 16) | (g << 8) | b;\n    }\n  }\n}\nid(respeaker).set_led_ring(colors);"
  - id: control_leds
    mode: single
    then:
      - lambda: "// Cache expensive component checks\nstatic bool last_respeaker_failed\
          \ = false;\nstatic bool last_wifi_connected = false;\nstatic bool last_api_connected\
          \ = false;\nstatic int last_voice_phase = -1;\nstatic bool last_timer_ringing\
          \ = false;\nstatic bool last_timer_active = false;\nstatic bool last_improv_ble\
          \ = false;\nstatic bool last_init_progress = false;\n\nbool respeaker_failed\
          \ = id(respeaker).is_failed();\nbool wifi_connected = id(wifi_id).is_connected();\n\
          bool api_connected = id(api_id).is_connected();\nint voice_phase = id(voice_assistant_phase);\n\
          bool new_timer_ringing = id(timer_ringing).state;\nbool improv_ble = id(improv_ble_in_progress);\n\
          bool init_progress = id(init_in_progress);\n\n// Only update if something\
          \ actually changed\nbool needs_update = (\n  respeaker_failed != last_respeaker_failed\
          \ ||\n  wifi_connected != last_wifi_connected ||\n  api_connected != last_api_connected\
          \ ||\n  voice_phase != last_voice_phase ||\n  new_timer_ringing != last_timer_ringing\
          \ ||\n  improv_ble != last_improv_ble ||\n  init_progress != last_init_progress\n\
          );\n\nif (!needs_update) return;\n\n// Update cache\nlast_respeaker_failed\
          \ = respeaker_failed;\nlast_wifi_connected = wifi_connected;\nlast_api_connected\
          \ = api_connected;\nlast_voice_phase = voice_phase;\nlast_timer_ringing\
          \ = new_timer_ringing;\nlast_improv_ble = improv_ble;\nlast_init_progress\
          \ = init_progress;\n\nif (respeaker_failed) {\n  id(control_leds_respeaker_startup_failed).execute();\n\
          \  return;\n}\n\n// Only check timers if we need to\nid(check_if_timers_active).execute();\n\
          if (id(is_timer_active)){\n  id(fetch_first_active_timer).execute();\n}\n\
          \n// Continue with existing logic...\nif (improv_ble) {\n  id(control_leds_improv_ble_state).execute();\n\
          } else if (init_progress) {\n  id(control_leds_init_state).execute();\n\
          } else if (!wifi_connected || !api_connected){\n  id(control_leds_no_ha_connection_state).execute();\n\
          } else if (new_timer_ringing) {\n  id(control_leds_timer_ringing).execute();\n\
          } else if (voice_phase == ${voice_assist_waiting_for_command_phase_id})\
          \ {\n  id(control_leds_voice_assistant_waiting_for_command_phase).execute();\n\
          } else if (voice_phase == ${voice_assist_listening_for_command_phase_id})\
          \ {\n  id(control_leds_voice_assistant_listening_for_command_phase).execute();\n\
          } else if (voice_phase == ${voice_assist_thinking_phase_id}) {\n  id(control_leds_voice_assistant_thinking_phase).execute();\n\
          } else if (voice_phase == ${voice_assist_replying_phase_id}) {\n  id(control_leds_voice_assistant_replying_phase).execute();\n\
          } else if (voice_phase == ${voice_assist_error_phase_id}) {\n  id(control_leds_voice_assistant_error_phase).execute();\n\
          } else if (voice_phase == ${voice_assist_not_ready_phase_id}) {\n  id(control_leds_voice_assistant_not_ready_phase).execute();\n\
          } else if (id(is_timer_active)) {\n  id(control_leds_timer_ticking).execute();\n\
          } else if (voice_phase == ${voice_assist_idle_phase_id}) {\n  id(control_leds_voice_assistant_idle_phase).execute();\n\
          }\n"
  - id: control_leds_respeaker_startup_failed
    then:
      - script.execute:
          id: led_set_effect
          effect: breathe
          r: 200.0
          g: 0.0
          b: 0.0
          speed: 0.5
          brightness: 0.6
  - id: control_leds_improv_ble_state
    then:
      - script.execute:
          id: led_set_effect
          effect: twinkle
          r: 255.0
          g: 200.0
          b: 160.0
          speed: 10.0
          brightness: 0.8
  - id: control_leds_init_state
    then:
      - if:
          condition:
            wifi.connected: null
          then:
            - script.execute:
                id: led_set_effect
                effect: twinkle
                r: 20.0
                g: 200.0
                b: 250.0
                speed: 20.0
                brightness: 1.0
          else:
            - script.execute:
                id: led_set_effect
                effect: twinkle
                r: 20.0
                g: 200.0
                b: 250.0
                speed: 4.0
                brightness: 0.6
  - id: control_leds_no_ha_connection_state
    then:
      - script.execute:
          id: led_set_effect
          effect: twinkle
          r: 255.0
          g: 0.0
          b: 0.0
          speed: 10.0
          brightness: 0.4
  - id: control_leds_voice_assistant_waiting_for_command_phase
    then:
      - lambda: 'id(animated_beam_position) = id(beam_direction).state;

          '
      - script.execute:
          id: led_set_effect
          effect: led_beam
          r: return id(user_led_ring_color_r);
          g: return id(user_led_ring_color_g);
          b: return id(user_led_ring_color_b);
          speed: 0.0
          brightness: 0.8
  - id: control_leds_voice_assistant_listening_for_command_phase
    then:
      - script.execute:
          id: led_set_effect
          effect: led_beam
          r: return id(user_led_ring_color_r);
          g: return id(user_led_ring_color_g);
          b: return id(user_led_ring_color_b);
          speed: 0.0
          brightness: 1.0
  - id: control_leds_voice_assistant_thinking_phase
    then:
      - script.execute:
          id: led_set_effect
          effect: breathe
          r: return id(user_led_ring_color_r);
          g: return id(user_led_ring_color_g);
          b: return id(user_led_ring_color_b);
          speed: 1.0
          brightness: 0.6
  - id: control_leds_voice_assistant_replying_phase
    then:
      - script.execute:
          id: led_set_effect
          effect: comet_ccw
          r: return id(user_led_ring_color_r);
          g: return id(user_led_ring_color_g);
          b: return id(user_led_ring_color_b);
          speed: 1.0
          brightness: 0.8
  - id: control_leds_voice_assistant_error_phase
    then:
      - script.execute:
          id: led_set_effect
          effect: breathe
          r: 255.0
          g: 0.0
          b: 0.0
          speed: 3.0
          brightness: 0.8
  - id: control_leds_voice_assistant_not_ready_phase
    then:
      - script.execute:
          id: led_set_effect
          effect: twinkle
          r: 255.0
          g: 0.0
          b: 0.0
          speed: 5.0
          brightness: 0.8
  - id: control_leds_volume_changed
    mode: restart
    then:
      - lambda: id(volume_display_active) = true;
      - delay: 2s
      - lambda: id(volume_display_active) = false;
  - id: control_leds_timer_ringing
    then:
      - script.execute:
          id: led_set_effect
          effect: breathe
          r: return id(user_led_ring_color_r);
          g: return id(user_led_ring_color_g);
          b: return id(user_led_ring_color_b);
          speed: 5.0
          brightness: 1.0
  - id: control_leds_timer_ticking
    then:
      - script.execute:
          id: led_set_effect
          effect: timer_tick
          r: return id(user_led_ring_color_r);
          g: return id(user_led_ring_color_g);
          b: return id(user_led_ring_color_b);
          speed: 1.0
          brightness: 0.7
  - id: control_leds_voice_assistant_idle_phase
    then:
      - script.execute:
          id: led_set_effect
          effect: 'off'
          r: 0.0
          g: 0.0
          b: 0.0
          speed: 0.0
          brightness: 0.0
  - id: ring_timer
    then:
      - script.execute: enable_repeat_one
      - script.execute:
          id: play_sound
          priority: true
          sound_file: timer_finished_sound
  - id: enable_repeat_one
    then:
      - media_player.repeat_one:
          id: external_media_player
          announcement: true
      - lambda: id(external_media_player)->set_playlist_delay_ms(1, 500);
  - id: disable_repeat
    then:
      - media_player.repeat_off:
          id: external_media_player
          announcement: true
      - lambda: id(external_media_player)->set_playlist_delay_ms(1, 0);
  - id: play_sound
    parameters:
      priority: bool
      sound_file: string
    then:
      - if:
          condition:
            lambda: return priority;
          then:
            - media_player.stop:
                id: external_media_player
                announcement: true
      - lambda: "if ( (id(external_media_player).state != media_player::MediaPlayerState::MEDIA_PLAYER_STATE_ANNOUNCING\
          \ ) || priority) {\n  id(external_media_player)\n    ->make_call()\n   \
          \ .set_media_url(\"file://\" + sound_file)\n    .set_announcement(true)\n\
          \    .perform();\n}"
  - id: fetch_first_active_timer
    mode: single
    then:
      - lambda: "static uint32_t last_fetch_time = 0;\nuint32_t now = millis();\n\n\
          // Only fetch every 500ms to reduce overhead\nif (now - last_fetch_time\
          \ < 500) return;\nlast_fetch_time = now;\n\nconst auto timers = id(va).get_timers();\n\
          if (timers.empty()) return;\n\nauto output_timer = timers.begin()->second;\n\
          for (auto &iterable_timer : timers) {\n  if (iterable_timer.second.is_active\
          \ &&\n      iterable_timer.second.seconds_left <= output_timer.seconds_left)\
          \ {\n    output_timer = iterable_timer.second;\n  }\n}\nid(first_active_timer)\
          \ = output_timer;\n"
  - id: check_if_timers_active
    then:
      - lambda: "const auto timers = id(va).get_timers();\nbool output = false;\n\
          if (timers.size() > 0) {\n  for (auto &iterable_timer : timers) {\n    if(iterable_timer.second.is_active)\
          \ {\n      output = true;\n    }\n  }\n}\nid(is_timer_active) = output;\n"
  - id: activate_stop_word_once
    then:
      - wait_until:
          condition:
            media_player.is_announcing:
              id: external_media_player
      - delay: 1s
      - if:
          condition:
            switch.is_off: timer_ringing
          then:
            - micro_wake_word.enable_model: stop
            - wait_until:
                not:
                  media_player.is_announcing:
                    id: external_media_player
            - if:
                condition:
                  switch.is_off: timer_ringing
                then:
                  - micro_wake_word.disable_model: stop
  - id: check_alarm
    then:
      - lambda: "id(publish_current_time).execute();\n// Check alarm\nif (id(alarm_on).state\
          \ && id(alarm_time).has_state()) {\n  // Get the stored alarm time from\
          \ the sensor\n  auto set_alarm_time = id(alarm_time).state;\n  if (set_alarm_time.length()\
          \ == 5 &&\n    isdigit(set_alarm_time[0]) && isdigit(set_alarm_time[1])\
          \ &&\n    isdigit(set_alarm_time[3]) && isdigit(set_alarm_time[4])) {\n\
          \    auto alarm_hour = std::stoi(set_alarm_time.substr(0, 2));\n    auto\
          \ alarm_minute = std::stoi(set_alarm_time.substr(3, 2));\n\n    // Trigger\
          \ action if current time matches alarm time\n    auto time_now = id(homeassistant_time).now();\n\
          \    if (time_now.hour == alarm_hour && time_now.minute == alarm_minute)\
          \ {\n      auto action = id(alarm_action).current_option();\n      if (action\
          \ == \"Play sound\") {\n        id(timer_ringing).turn_on();\n      } else\
          \ if (action == \"Send event\") {\n        id(send_alarm_event).execute();\n\
          \      } else if (action == \"Sound and event\") {\n        id(timer_ringing).turn_on();\n\
          \        id(send_alarm_event).execute();\n      }\n    }\n  } else {\n \
          \   ESP_LOGW(\"alarm\", \"Incorrect alarm time setting\");\n  }\n}"
  - id: send_alarm_event
    then:
      - homeassistant.event:
          event: esphome.alarm_ringing
  - id: send_tts_uri_event
    parameters:
      tts_uri: string
    then:
      - homeassistant.event:
          event: esphome.tts_uri
          data:
            uri: return tts_uri;
  - id: send_stt_text_event
    parameters:
      stt_text: string
    then:
      - homeassistant.event:
          event: esphome.stt_text
          data:
            text: return stt_text;
  - id: publish_current_time
    mode: single
    then:
      - lambda: "static std::string last_time_string = \"\";\nauto time_now = id(homeassistant_time).now();\n\
          std::string current_time_string = time_now.strftime(\"%H:%M\");\n\n// Only\
          \ publish if time actually changed\nif (current_time_string != last_time_string)\
          \ {\n  id(current_time).publish_state(current_time_string);\n  last_time_string\
          \ = current_time_string;\n}"
i2s_audio:
  - id: i2s_output
    i2s_lrclk_pin:
      number: GPIO7
      allow_other_uses: true
    i2s_bclk_pin:
      number: GPIO8
      allow_other_uses: true
  - id: i2s_input
    i2s_lrclk_pin:
      number: GPIO7
      allow_other_uses: true
    i2s_bclk_pin:
      number: GPIO8
      allow_other_uses: true
microphone:
  - platform: i2s_audio
    id: i2s_mics
    i2s_din_pin: GPIO43
    adc_type: external
    pdm: false
    sample_rate: 48000
    bits_per_sample: 32bit
    i2s_mode: secondary
    i2s_audio_id: i2s_input
    channel: stereo
speaker:
  - platform: i2s_audio
    id: i2s_audio_speaker
    sample_rate: 48000
    i2s_mode: secondary
    i2s_dout_pin: GPIO44
    bits_per_sample: 32bit
    i2s_audio_id: i2s_output
    dac_type: external
    channel: stereo
    timeout: never
    buffer_duration: 100ms
    audio_dac: aic3104_dac
  - platform: mixer
    id: mixing_speaker
    output_speaker: i2s_audio_speaker
    num_channels: 2
    task_stack_in_psram: true
    source_speakers:
      - id: announcement_mixing_input
        timeout: never
      - id: media_mixing_input
        timeout: never
  - platform: resampler
    id: announcement_resampling_speaker
    output_speaker: announcement_mixing_input
    sample_rate: 48000
    bits_per_sample: 16
  - platform: resampler
    id: media_resampling_speaker
    output_speaker: media_mixing_input
    sample_rate: 48000
    bits_per_sample: 16
sendspin:
  id: sendspin_hub
  task_stack_in_psram: true
  kalman_process_error: 0.01
media_source:
  - platform: sendspin
    id: sendspin_source
  - platform: http_request
    id: http_source
    buffer_size: 500000
  - platform: file
    id: file_source
    files:
      - id: mute_switch_on_sound
        file: ${mute_switch_on_sound_file}
      - id: mute_switch_off_sound
        file: ${mute_switch_off_sound_file}
      - id: timer_finished_sound
        file: ${timer_finished_sound_file}
      - id: wake_word_triggered_sound
        file: ${wake_word_triggered_sound_file}
      - id: error_cloud_expired
        file: ${error_cloud_expired_sound_file}
media_player:
  - platform: sendspin
    id: sendspin_group_media_player
  - platform: speaker_source
    id: external_media_player
    name: Media Player
    announcement_speaker: announcement_resampling_speaker
    media_speaker: media_resampling_speaker
    announcement_pipeline:
      format: FLAC
      num_channels: 1
      sample_rate: 48000
    media_pipeline:
      format: FLAC
      num_channels: 2
      sample_rate: 48000
    volume_increment: 0.05
    volume_min: 0.0
    volume_max: 1.0
    sources:
      - file_source
      - http_source
      - sendspin_source
    on_mute:
      - delay: 100ms
      - script.execute: control_leds_volume_changed
    on_unmute:
      - delay: 100ms
      - script.execute: control_leds_volume_changed
    on_volume:
      if:
        condition:
          - lambda: return !id(init_in_progress);
        then:
          - delay: 100ms
          - script.execute: control_leds_volume_changed
    on_announcement:
      - mixer_speaker.apply_ducking:
          id: media_mixing_input
          decibel_reduction: 20
          duration: 0.0s
    on_state:
      if:
        condition:
          and:
            - switch.is_off: timer_ringing
            - not:
                voice_assistant.is_running: null
            - not:
                media_player.is_announcing: external_media_player
        then:
          - mixer_speaker.apply_ducking:
              id: media_mixing_input
              decibel_reduction: 0
              duration: 1.0s
external_components:
  - source:
      type: git
      url: https://github.com/formatBCE/esphome
      ref: respeaker_microphone
    components:
      - i2s_audio
    refresh: 0s
  - source:
      type: git
      url: https://github.com/formatBCE/Respeaker-XVF3800-ESPHome-integration
      ref: main
    components:
      - respeaker_xvf3800
      - aic3104
    refresh: 0s
  - source:
      type: git
      url: https://github.com/esphome/esphome
      ref: 7f34908569650e5a8b8c83e6bf89fea561218880
    components:
      - mixer
  - source:
      type: git
      url: https://github.com/esphome/esphome
      ref: 6006b896a691ad38d8045ac67564c168973d1a1d
    components:
      - resampler
  - source:
      type: git
      url: https://github.com/esphome/esphome
      ref: 9148832ea4e54907bad71a24d4ced1ce6c862433
    components:
      - audio
  - source:
      type: git
      url: https://github.com/esphome/esphome
      ref: bff22983a390352360796f8e1363127e0cd1f898
    components:
      - media_player
  - source:
      type: git
      url: https://github.com/esphome/esphome
      ref: a6c0a861a014e64c67d46115eba8e5370777b80a
    components:
      - mdns
      - sendspin
  - source:
      type: git
      url: https://github.com/esphome/esphome
      ref: 928204066ce0082404573ea1c6a0b58aeebbd7c6
    refresh: 0s
    components:
      - file
      - http_request
      - media_source
      - speaker_source
respeaker_xvf3800:
  id: respeaker
  address: 44
  mute_switch:
    id: mic_mute_switch
    name: Microphone Mute
    update_interval: 1s
    on_turn_on:
      - if:
          condition:
            and:
              - lambda: return !id(init_in_progress);
              - switch.is_on: mute_sound
          then:
            - script.execute:
                id: play_sound
                priority: false
                sound_file: mute_switch_on_sound
    on_turn_off:
      - if:
          condition:
            and:
              - lambda: return !id(init_in_progress);
              - switch.is_on: mute_sound
          then:
            - script.execute:
                id: play_sound
                priority: false
                sound_file: mute_switch_off_sound
  dfu_version:
    name: Firmware Version
    update_interval: 120s
  led_beam_sensor:
    name: Voice Beam Direction
    id: beam_direction
    internal: true
  firmware:
    url: https://github.com/formatBCE/Respeaker-XVF3800-ESPHome-integration/raw/refs/heads/main/application_xvf3800_inthost-lr48-sqr-i2c-v1.0.7-release.bin
    version: 1.0.7
    md5: 043a848f544ff2c7265ac19685daf5de
audio_dac:
  - platform: aic3104
    id: aic3104_dac
    i2c_id: internal_i2c
micro_wake_word:
  id: mww
  microphone:
    microphone: i2s_mics
    channels: 1
  stop_after_detection: false
  models:
    - model: https://github.com/kahrendt/microWakeWord/releases/download/okay_nabu_20241226.3/okay_nabu.json
      id: okay_nabu
    - model: https://raw.githubusercontent.com/formatBCE/Respeaker-Lite-ESPHome-integration/refs/heads/main/microwakeword/models/v2/kenobi.json
      id: kenobi
    - model: hey_jarvis
      id: hey_jarvis
    - model: hey_mycroft
      id: hey_mycroft
    - model: https://github.com/kahrendt/microWakeWord/releases/download/stop/stop.json
      id: stop
      internal: true
  vad:
    probability_cutoff: 0.05
  on_wake_word_detected:
    - if:
        condition:
          switch.is_off: mic_mute_switch
        then:
          - if:
              condition:
                switch.is_on: timer_ringing
              then:
                - switch.turn_off: timer_ringing
              else:
                - if:
                    condition:
                      voice_assistant.is_running: null
                    then:
                      voice_assistant.stop: null
                    else:
                      - if:
                          condition:
                            media_player.is_announcing:
                              id: external_media_player
                          then:
                            - media_player.stop:
                                announcement: true
                                id: external_media_player
                          else:
                            - if:
                                condition:
                                  switch.is_on: wake_sound
                                then:
                                  - script.execute:
                                      id: play_sound
                                      priority: true
                                      sound_file: wake_word_triggered_sound
                                  - delay: 300ms
                            - voice_assistant.start:
                                wake_word: return wake_word;
select:
  - platform: template
    name: Wake word sensitivity
    optimistic: true
    initial_option: Slightly sensitive
    restore_value: true
    entity_category: config
    options:
      - Slightly sensitive
      - Moderately sensitive
      - Very sensitive
    on_value:
      lambda: "if (x == \"Slightly sensitive\") {\n  id(okay_nabu).set_probability_cutoff(217);\
        \    // 0.85 -> 0.000 FAPH on DipCo (Manifest's default)\n  id(hey_jarvis).set_probability_cutoff(247);\
        \   // 0.97 -> 0.563 FAPH on DipCo (Manifest's default)\n  id(hey_mycroft).set_probability_cutoff(253);\
        \  // 0.99 -> 0.567 FAPH on DipCo\n} else if (x == \"Moderately sensitive\"\
        ) {\n  id(okay_nabu).set_probability_cutoff(176);    // 0.69 -> 0.376 FAPH\
        \ on DipCo\n  id(hey_jarvis).set_probability_cutoff(235);   // 0.92 -> 0.939\
        \ FAPH on DipCo\n  id(hey_mycroft).set_probability_cutoff(242);  // 0.95 ->\
        \ 1.502 FAPH on DipCo (Manifest's default)\n} else if (x == \"Very sensitive\"\
        ) {\n  id(okay_nabu).set_probability_cutoff(143);    // 0.56 -> 0.751 FAPH\
        \ on DipCo\n  id(hey_jarvis).set_probability_cutoff(212);   // 0.83 -> 1.502\
        \ FAPH on DipCo\n  id(hey_mycroft).set_probability_cutoff(237);  // 0.93 ->\
        \ 1.878 FAPH on DipCo\n}"
  - platform: logger
    id: logger_select
    name: Logger Level
    disabled_by_default: true
  - platform: template
    optimistic: true
    name: Alarm action
    id: alarm_action
    icon: mdi:bell-plus
    options:
      - Play sound
      - Send event
      - Sound and event
    initial_option: Play sound
    on_value:
      then:
        - lambda: id(saved_alarm_action) = x;
  - platform: template
    name: LED Ring Color Preset
    id: user_led_color_preset
    icon: mdi:palette
    entity_category: config
    optimistic: true
    restore_value: true
    initial_option: Custom
    options:
      - Purple
      - Blue
      - Green
      - Yellow
      - Cyan
      - White
      - Orange
      - Pink
      - Custom
    on_value:
      - lambda: "if (x == \"Purple\") {\n  id(user_led_ring_color_r) = 255.0f;\n \
          \ id(user_led_ring_color_g) = 0.0f;\n  id(user_led_ring_color_b) = 255.0f;\n\
          } else if (x == \"Blue\") {\n  id(user_led_ring_color_r) = 0.0f;\n  id(user_led_ring_color_g)\
          \ = 0.0f;\n  id(user_led_ring_color_b) = 255.0f;\n} else if (x == \"Green\"\
          ) {\n  id(user_led_ring_color_r) = 0.0f;\n  id(user_led_ring_color_g) =\
          \ 255.0f;\n  id(user_led_ring_color_b) = 0.0f;\n} else if (x == \"Yellow\"\
          ) {\n  id(user_led_ring_color_r) = 255.0f;\n  id(user_led_ring_color_g)\
          \ = 255.0f;\n  id(user_led_ring_color_b) = 0.0f;\n} else if (x == \"Cyan\"\
          ) {\n  id(user_led_ring_color_r) = 0.0f;\n  id(user_led_ring_color_g) =\
          \ 255.0f;\n  id(user_led_ring_color_b) = 255.0f;\n} else if (x == \"White\"\
          ) {\n  id(user_led_ring_color_r) = 255.0f;\n  id(user_led_ring_color_g)\
          \ = 255.0f;\n  id(user_led_ring_color_b) = 255.0f;\n} else if (x == \"Orange\"\
          ) {\n  id(user_led_ring_color_r) = 255.0f;\n  id(user_led_ring_color_g)\
          \ = 128.0f;\n  id(user_led_ring_color_b) = 0.0f;\n} else if (x == \"Pink\"\
          ) {\n  id(user_led_ring_color_r) = 255.0f;\n  id(user_led_ring_color_g)\
          \ = 50.0f;\n  id(user_led_ring_color_b) = 200.0f;\n}"
voice_assistant:
  id: va
  microphone:
    microphone: i2s_mics
    channels: 0
  media_player: external_media_player
  micro_wake_word: mww
  use_wake_word: false
  noise_suppression_level: 0
  auto_gain: 0 dbfs
  volume_multiplier: 1
  on_client_connected:
    - if:
        condition:
          - lambda: return id(init_in_progress);
          - switch.is_on: mic_mute_switch
        then:
          - switch.turn_off: mic_mute_switch
    - lambda: id(init_in_progress) = false;
    - micro_wake_word.start: null
    - lambda: id(voice_assistant_phase) = ${voice_assist_idle_phase_id};
    - script.execute: control_leds
  on_client_disconnected:
    - voice_assistant.stop: null
    - lambda: id(voice_assistant_phase) = ${voice_assist_not_ready_phase_id};
    - script.execute: control_leds
  on_error:
    - if:
        condition:
          and:
            - lambda: return !id(init_in_progress);
            - lambda: return code != "duplicate_wake_up_detected";
            - lambda: return code != "stt-no-text-recognized";
        then:
          - lambda: id(voice_assistant_phase) = ${voice_assist_error_phase_id};
          - script.execute: control_leds
    - if:
        condition:
          - lambda: return code == "cloud-auth-failed";
        then:
          - script.execute:
              id: play_sound
              priority: true
              sound_file: error_cloud_expired
  on_start:
    - mixer_speaker.apply_ducking:
        id: media_mixing_input
        decibel_reduction: 20
        duration: 0.0s
  on_listening:
    - lambda: id(voice_assistant_phase) = ${voice_assist_waiting_for_command_phase_id};
    - script.execute: control_leds
  on_stt_vad_start:
    - lambda: id(voice_assistant_phase) = ${voice_assist_listening_for_command_phase_id};
    - script.execute: control_leds
  on_stt_vad_end:
    - lambda: id(voice_assistant_phase) = ${voice_assist_thinking_phase_id};
    - script.execute: control_leds
  on_intent_progress:
    - if:
        condition:
          lambda: return !x.empty();
        then:
          - lambda: id(voice_assistant_phase) = ${voice_assist_replying_phase_id};
          - script.execute: control_leds
          - script.execute: activate_stop_word_once
  on_tts_start:
    - if:
        condition:
          lambda: return id(voice_assistant_phase) != ${voice_assist_replying_phase_id};
        then:
          - lambda: id(voice_assistant_phase) = ${voice_assist_replying_phase_id};
          - script.execute: control_leds
          - script.execute: activate_stop_word_once
  on_tts_end:
    - script.execute:
        id: send_tts_uri_event
        tts_uri: return x;
  on_stt_end:
    - script.execute:
        id: send_stt_text_event
        stt_text: return x;
  on_end:
    - wait_until:
        not:
          voice_assistant.is_running: null
    - mixer_speaker.apply_ducking:
        id: media_mixing_input
        decibel_reduction: 0
        duration: 1.0s
    - if:
        condition:
          lambda: return id(voice_assistant_phase) == ${voice_assist_error_phase_id};
        then:
          - delay: 1s
    - lambda: id(voice_assistant_phase) = ${voice_assist_idle_phase_id};
    - script.execute: control_leds
  on_timer_finished:
    - switch.turn_on: timer_ringing
    - lambda: 'id(next_timer).publish_state(-1);

        id(next_timer_name).publish_state("-");

        '
  on_timer_started:
    - lambda: "id(check_if_timers_active).execute();\nif (id(is_timer_active)) {\n\
        \  id(fetch_first_active_timer).execute();\n  id(next_timer).publish_state(id(first_active_timer).seconds_left);\n\
        \  id(next_timer_name).publish_state(id(first_active_timer).name);\n}\n"
    - script.execute: control_leds
  on_timer_cancelled:
    - lambda: "id(check_if_timers_active).execute();\nif (id(is_timer_active)) {\n\
        \  id(fetch_first_active_timer).execute();\n  id(next_timer).publish_state(id(first_active_timer).seconds_left);\n\
        \  id(next_timer_name).publish_state(id(first_active_timer).name);\n} else\
        \ {\n  id(next_timer).publish_state(-1);\n  id(next_timer_name).publish_state(\"\
        -\");\n}\n"
    - script.execute: control_leds
  on_timer_updated:
    - lambda: "id(check_if_timers_active).execute();\nif (id(is_timer_active)) {\n\
        \  id(fetch_first_active_timer).execute();\n  id(next_timer).publish_state(id(first_active_timer).seconds_left);\n\
        \  id(next_timer_name).publish_state(id(first_active_timer).name);\n}\n"
    - script.execute: control_leds
  on_timer_tick:
    - lambda: "id(fetch_first_active_timer).execute();\nint seconds_left = id(first_active_timer).seconds_left;\n\
        if (seconds_left % 5 == 0) {\n  id(next_timer).publish_state(seconds_left);\n\
        }\nif (id(current_led_effect) == \"timer_tick\") {\n  id(control_leds_timer_ticking).execute();\n\
        }\n"
button:
  - platform: factory_reset
    id: factory_reset_button
    name: Factory Reset
    entity_category: diagnostic
    internal: true
  - platform: restart
    id: restart_button
    name: Restart
    entity_category: config
    disabled_by_default: true
    icon: mdi:restart
debug:
  update_interval: 5s
